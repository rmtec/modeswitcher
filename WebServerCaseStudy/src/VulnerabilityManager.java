import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.regex.Pattern;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;

public class VulnerabilityManager {
	
	//https://csrc.nist.gov/CSRC/media/Projects/National-Vulnerability-Database/documents/web%20service%20documentation/Automation%20Support%20for%20CVE%20Retrieval.pdf
	private static final String nvdBaseUrl = "https://services.nvd.nist.gov/rest/json/";
	private static final String debianTrackerBaseUrl = "https://security-tracker.debian.org/tracker/data/json";

	private HashMap<String, Software> software;
	private HashMap<String, Vulnerability> vulnerabilities;
	private String debianRelease;
	private LocalDate releaseDate;
	
	private static String cvePattern = "CVE-\\d\\d\\d\\d-\\d\\d\\d\\d+";

	public VulnerabilityManager() {
		software = new HashMap<String, Software>();
		vulnerabilities = new HashMap<String, Vulnerability>();
	}
	
	public VulnerabilityManager(HashMap<String, Software> software, String debianRelease, String releaseDate) {
		this();
		setSoftware(software);
		setDebianRelease(debianRelease);
		setReleaseDate(releaseDate);
	}

	public HashMap<String, Software> getSoftware() {
		return software;
	}

	public void setSoftware(HashMap<String, Software> software) {
		this.software = software;
	}
	
	public String getDebianrelease() {
		return debianRelease;
	}
	
	public void setDebianRelease(String debianRelease) {
		this.debianRelease = debianRelease;
	}
	
	public HashMap<String, Vulnerability> getVulnerabilities() {
		return vulnerabilities;
	}

	public void setVulnerabilities(HashMap<String, Vulnerability> vulnerabilities) {
		this.vulnerabilities = vulnerabilities;
	}
	
	public void refreshVulnerabilities() {
		for (Software s : software.values()) {
			System.out.println("resfreshVulnerabilitiesPerProduct " + s.getVendor() + " " + s.getProduct() + " " + s.getVersion());
			resfreshVulnerabilitiesPerProduct(s.getVendor(),s.getProduct(),s.getVersion());
		}
	}	
	
	public void resfreshVulnerabilitiesPerProduct(String vendor, String product, String version) {
		//https://services.nvd.nist.gov/rest/json/cpes/1.0?cpeMatchString=cpe:2.3:a:apache:http_server:2.4.38:*:*:*:*:*:*:*&addOns=cves
		//result.cpes[0].vulnerabilities
		
		ObjectMapper objectMapper = new ObjectMapper();
		URL url = null;
		try {
			url = new URL(nvdBaseUrl + "cpes/1.0?cpeMatchString=cpe:2.3:a:"+vendor+":"+product+":"+version+":*:*:*:*:*:*:*&addOns=cves");
		} catch (MalformedURLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		if(url != null) {
			try {
			    JsonNode jsonNode = objectMapper.readValue(url,JsonNode.class);
			    JsonNode cpesNode = jsonNode.at("/result/cpes");
			    if(cpesNode.isArray()) {
			    	ArrayNode cpesArray = (ArrayNode) cpesNode;
				    JsonNode cpeNode = cpesArray.get(0);
				    JsonNode vulnerabilitiesNode = cpeNode.get("vulnerabilities");
				    if(vulnerabilitiesNode.isArray()){
				        ArrayNode arrayNode = (ArrayNode) vulnerabilitiesNode;
				        
				        //System.out.println("CVE             published lastModified Score");
				        //String format = "%-14s %10s %12s %5.1f\n";
				        for(int i = 0; i < arrayNode.size(); i++) {
				            String cveId = arrayNode.get(i).asText(); //CVE-1999-0236
					        //System.out.println(cveId); 
					        Vulnerability vuln = getCveDetails(cveId);
					        if(vuln != null) {
					        	/*System.out.format(format, 
					        			cveId,
					        			vuln.getPublishDate(),
					        			vuln.getPublishDate(),
					        			vuln.getScore()
								);*/
					        	addVulnerability(cveId, vuln, "cpe:/:"+vendor+":"+product+":"+version);
					        }
				        }
						System.out.println("----------------------------------------------------------------------------");
				    }
			    }
			    
			} catch (IOException e) {
			    e.printStackTrace();
			}
		}
	}
	
	private static boolean checkCVEString(String cve) {
		return Pattern.matches(cvePattern, cve);
	}
	
	public Vulnerability getCveDetails(String cve) {
		
		if(checkCVEString(cve)) {
			
			//System.out.println("getCveDetails for " + cve);
		
			//https://services.nvd.nist.gov/rest/json/cve/1.0/CVE-2009-0796
			//result.CVE_Items[0].cve.impact.baseMetricV3.cvssV3.baseScore
			//result.CVE_Items[0].cve.publishedDate
			//result.CVE_Items[0].cve.lastModifiedDate
			
			ObjectMapper objectMapper = new ObjectMapper();
			URL url = null;
			try {
				url = new URL(nvdBaseUrl + "cve/1.0/" + cve);
			} catch (MalformedURLException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			JsonNode baseScoreNode = null;
			JsonNode publishedDateNode = null;
			JsonNode lastModifiedDateNode = null;
			if(url != null) {
				try {
				    JsonNode jsonNode = objectMapper.readValue(url,JsonNode.class);
				    JsonNode CVE_ItemsNode = jsonNode.at("/result/CVE_Items");
				    if(CVE_ItemsNode.isArray()) {
				    	ArrayNode CVE_ItemsArray = (ArrayNode) CVE_ItemsNode;
					    JsonNode cveNode = CVE_ItemsArray.get(0);
					    publishedDateNode = cveNode.get("publishedDate"); //2020-08-07T16:15Z
					    lastModifiedDateNode = cveNode.get("lastModifiedDate"); //2020-08-07T16:15Z
					    if (cveNode.has("/impact/baseMetricV3/cvssV3/baseScore")) {
					    	baseScoreNode = cveNode.at("/impact/baseMetricV3/cvssV3/baseScore");
					    }else {
					    	baseScoreNode = cveNode.at("/impact/baseMetricV2/cvssV2/baseScore");
					    }
				    }
				    
				} catch (IOException e) {
				    e.printStackTrace();
				}
			}
			return new Vulnerability(
					publishedDateNode.asText("9999-12-31T12:00Z").substring(0, 10),
					lastModifiedDateNode.asText("9999-12-31T12:00Z").substring(0, 10),
					cve,
					baseScoreNode.asDouble(0)
			);
		}else {
			System.out.println("cve " + cve + " is invalid!");
			return null;
		}
	}	

	
	public void refreshPatches() {
		//https://security-tracker.debian.org/tracker/data/json
		//apache2.CVE-2001-1534.releases.buster.status open/resolved
		//apache2.CVE-2001-1534.releases.buster.status open/resolved
		
		if(this.debianRelease == null) {
			System.out.println("Parameter debianRelease is undefined"); 
			return;
		}
		
		SimpleDateFormat formatter= new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date(System.currentTimeMillis());
		
		ObjectMapper objectMapper = new ObjectMapper();
		URL url = null;
		try {
			url = new URL(debianTrackerBaseUrl);
		} catch (MalformedURLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}	
		if(url != null) {
			try {
				System.out.println("Loading Data from Debian Security Tracker"); 
			    JsonNode jsonNode = objectMapper.readValue(url,JsonNode.class);
			    
			    for (Software s : software.values()) {
			    	if(jsonNode.has(s.getDebianPackage())){
			    		System.out.println("Package " + s.getDebianPackage()+ " found"); 
					    JsonNode packageNode = jsonNode.get(s.getDebianPackage()); //apache2
					    Iterator<Map.Entry<String, JsonNode>> iter = packageNode.fields();	   
					    //System.out.println("CVE            status");
				        //String format = "%-14s %10s\n";
					    while (iter.hasNext()) { //next cve
				            Map.Entry<String, JsonNode> cveNode = iter.next();
				            String cveId = cveNode.getKey();
						    String status = cveNode.getValue().at("/releases/" + debianRelease + "/status").asText(); //open/resolved
						    String urgency = cveNode.getValue().at("/releases/" + debianRelease + "/urgency").asText(); //unimportant/low/medium/high
					        //System.out.format(format, cveId, status);					        
						    if(checkCVEString(cveId) && (status.equals("resolved") || urgency.equals("unimportant"))) {
						    	if(status.equals("open") && urgency.equals("unimportant")) {
						    		System.out.println("WARNING: " + cveId +" is open, but considered as unimportant");	
						    	}
						    	addPatch(formatter.format(date), cveId, "cpe:/:"+s.getVendor()+":"+s.getProduct()+":"+s.getVersion());
						    }else {
						    	System.out.println(cveId +" is "+ status);	
						    }
				        }
			    	}else{
			    		System.out.println("Package " + s.getProduct()+ " not found"); 
			    	}
			    	System.out.println("----------------------------------------------------------------------------");
				}
			} catch (IOException e) {
			    e.printStackTrace();
			}
		}
	}
	
	public boolean addVulnerability(String date, String cveId, double score, String cpe) {
		Vulnerability vuln = new Vulnerability(date, cveId, score);
		addVulnerability(cveId, vuln, cpe);
		return false;
	}
	
	public void addVulnerability(String date, String modifiedDate, String cveId, double score, String cpe) {
		Vulnerability vuln = new Vulnerability(date, modifiedDate, cveId, score);
		addVulnerability(cveId, vuln, cpe);
	}
	
	public boolean addVulnerability(String cveId, Vulnerability vuln, String cpe) {
		boolean changes = false;
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy");
		if(checkCVEString(cveId) && vuln != null) {
			if(vuln.getPublishDate().getYear() < this.releaseDate.getYear()) {
				System.out.println("WARNING: "+ cveId + " was ignored, because the CVE was published "+ formatter.format(vuln.getPublishDate()) + " before the release year of the distribution");
			}else {
				if(this.vulnerabilities.containsKey(cveId)){
					System.out.print("[" + cveId + "] already known");
					if(this.vulnerabilities.get(cveId).getModifiedDate() == null) {
						//do nothing
						System.out.print(", nothing changed!");
					}else { // this.vulnerabilities.get(cveId).getModifiedDate() != null
						if(vuln.getModifiedDate() != null && this.vulnerabilities.get(cveId).getModifiedDate().isEqual(vuln.getModifiedDate())) {
							changes = putVulnerability(cveId, vuln, cpe); //override with newer version
						}else {
							System.out.print(", nothing changed!");
						}
					}
					System.out.println();
				}else { //new
					changes = putVulnerability(cveId, vuln, cpe);
				}
			}
		}
		return changes;
	}
	
	private boolean putVulnerability(String cveId, Vulnerability vuln, String cpe){
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		this.vulnerabilities.put(cveId, vuln); //override existing
		if(this.software.containsKey(cpe)) {
			Software sw = this.software.get(cpe);
			sw.addVulnerability(vuln);
			System.out.println(formatter.format(vuln.getPublishDate()) + " " + sw + " new vulnerability [" + cveId + "] score:" + vuln.getScore());
			return true;
		}else {
			System.out.println("WARNING: " + cpe + " not found");
		}
		return true;
	}
		
	public boolean addPatch(String date, String cveId, String cpe) {
		if(this.vulnerabilities.containsKey(cveId)) {
			if(vulnerabilities.get(cveId).getResolvedDate() != null) {
				System.out.println("[" + cveId + "] already resolved!");
			}else {
				vulnerabilities.get(cveId).setResolvedDate(date);
				if(this.software.containsKey(cpe)) {
					Software sw = this.software.get(cpe);
					System.out.println(date + " " + sw + " new patch for [" + cveId + "]");
					return true;
				}else {
					System.out.println("WARNING: " + cpe + " not found");
				}
			}
		}else {
			System.out.println("WARNING: Could not add patch! " + cveId + " not found");
		}
		return false;
	}

	public LocalDate getReleaseDate() {
		return releaseDate;
	}

	public void setReleaseDate(LocalDate releaseDate) {
		this.releaseDate = releaseDate;
	}
	
	public void setReleaseDate(String releaseDate) {
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		this.releaseDate = LocalDate.parse(releaseDate, formatter);
	}
	
}
